# Новый год и спешка
# В последний день уходящего 2016 года Лимак собирается принять участие в соревновании по спортивному программированию. Соревнование начнётся в 20:00 и будет продолжаться четыре часа, то есть ровно до полуночи. Участникам будет предложено n задач, упорядоченных по возрастанию сложности, то есть задача 1 будет самой лёгкой, а задача номер n — самой сложной. Лимак знает, что ему потребуется 5·i минут на решение i-й задачи.
# Друзья Лимака планирую устроить роскошную новогоднюю вечеринку и Лимак хочет прибыть в полночь или ранее. Он знает, что ему требуется ровно k минут чтобы добрать до места проведения вечеринки от своего дома, где он собирается участвовать в соревновании.
# Сколько максимум задач может успеть решить Лимак, так чтобы не опоздать на новогоднюю вечеринку?
# Входные данные
# В первой строке входных данных записаны два целых числа n и k (1 ≤ n ≤ 10, 1 ≤ k ≤ 240) — количество задач в соревновании и количество минут, за которое Лимак доберётся от дома до места проведения вечеринки.
# Выходные данные
# Выведите одно целое число, равное максимальному количеству задач, которое может решить Лимак, так чтобы прибыть на новогоднюю вечеринку ровно в полночь или раньше.
# Примечание
# В первом примере на соревновании участникам предложено 3 задачи и Лимаку требуется 222 минуты, чтобы доехать до места проведения вечеринки. Для решения задач требуется 5, 10 и 15 минут соответственно. Лимак может решить первые две задачи, потравив на это 5 + 10 = 15 минут, после чего выехать в 20:15 и приехать на вечеринку в 23:57 (через 222 минуты). Таким образом он решит две задачи, но на решение третьей времени уже не хватит и ответ равен 2.
# Во втором примере Лимак может решить все 4 задачи за 5 + 10 + 15 + 20 = 50 минут. В 20:50 он сможет выехать из дома и прибыть на вечеринку ровно в полночь.
# В третьем примере Лимаку нужна только 1 минута, чтобы оказаться на вечеринке, так что ему хватит времени для решения всех 7 задач.

countTask, time = map(int, input().split())
finishedTask = 0  # кол-во задач
d = 240 - time  # время на задачи
i = 1 # позиция задачи

while d >= 0:  # пока время на задачи есть 
    if d - i*5 >= 0 and countTask >= i: # проверяем чтобы время на задачи было больше либо равно 0 и кол-во задачт больше либо равно позиции задачи
        d = d - i*5                     # если условие выше выполняем, то уменьшаем время на задачи 
        finishedTask = finishedTask + 1 # и увеличиваем число решенных задач на 1
        i=i+1                           # и увеличииваем позицию задачи
    else:                               # иначе тормозим цикл
        break
print(finishedTask)
